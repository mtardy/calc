%{

/* compile: leg -o calc.c calc.leg
 *			cc -o calc calc.c
 *
 * run:		echo "2+3" | ./calc
 */

#include <stdbool.h>
#include <sysexits.h>

union u_t {
	int		ival;
	char	*sval;
};
#define YYSTYPE union u_t
YYSTYPE yylval;

#define SYMBOL_TABLE_CHUNK 1024

typedef struct symbol_t {
	char	*ident;
	bool	 defined;
	int	 value;
} symbol_t;

typedef struct table_t {
	symbol_t	**array;
	size_t		  size;       // size_t allows your table to grow past the 1G element limit of a 32-bit number on 64-bit machines
	size_t		  capacity;
} table_t;

#define TABLE_INITIALISER { NULL, 0, 0 } // first call to table_insert() will initialise storage

table_t table = TABLE_INITIALISER;       // safe but not strictly needed on Unix because BSS segment is initialised to all zeroes

void *memcheck(void *ptr)
{
	if (NULL == ptr) {
	fprintf(stderr, "Error: out of memory\n");
	exit(EX_OSERR);  // this is as close as we have for 'resource unavailable'
	}
	return ptr;
}

ssize_t table_search(table_t *table, char *ident)
{
	ssize_t l = 0, r = table->size - 1;      // no longer needed as parameters if we pass a table as the first parameter
	while (l <= r) {                       // swapped the order of l and r because I always visualise data as laid out from left-to-right ;-)
		ssize_t mid = (l + r) / 2;
		int cmpres= strcmp(table->array[mid]->ident, ident);
		if      (cmpres > 0) 	r = mid - 1;
		else if (cmpres < 0) 	l = mid + 1;
		else 					return mid;  // non-negative result => element found at this index
	}
	return -1 - l;  // negative result => 'not found', reflected around -1 instead of 0 to allow 'not found' at index 0
}

ssize_t table_insert(table_t *table, symbol_t *element, size_t pos)
{
	if (pos > table->size) {  // don't need to check for pos < 0 because size_t is unsigned
		return -1;
	}

	if (table->size  >= table->capacity) {
		// on the first call table->array will be NULL and realloc() will behave like malloc()
		table->array = memcheck(realloc(table->array, sizeof(symbol_t *) * (table->capacity + SYMBOL_TABLE_CHUNK)));
		table->capacity += SYMBOL_TABLE_CHUNK;
	}

	memmove(table->array + pos + 1, table->array + pos, sizeof(*table->array) * (table->size - pos));
	table->array[pos] = element;
	return ++(table->size);
}

symbol_t *intern(char *ident, bool create)
{
	ssize_t res = table_search(&table, ident);  // < 0 => not found
	if (res >= 0) return table.array[res];
	if (!create)  return NULL;
	res= -1 - res; // 'un-negate' the resulr by reflecting it around X=-1
	symbol_t *new_symbol = memcheck(calloc(1, sizeof(symbol_t))); // calloc() will init all content to 0 (including .value member)
	new_symbol->ident = memcheck(strdup(ident));  // check for out-of-memory
	new_symbol->defined = false;                  // implicit in calloc(), but safer to do it explicitly anyway
	table_insert(&table, new_symbol, res);
	return new_symbol;
}

symbol_t *update_value(symbol_t * s, int value)
{
	s->value = value;
	s->defined = true;
	return s;
}

char *ident_buf;

%}

start	=	e:exp					{ yylval = e }

exp		=	- (a:assign				{ $$ = a }
			| s:sum 				{ $$ = s }
			)

assign	=	l:IDENT 				{ ident_buf = strdup(l.sval) } 
			EQUAL n:sum				{ symbol_t *nsymb = intern(ident_buf, true); $$.ival = update_value(nsymb, n.ival)->value; free(ident_buf) }

sum		=	PLUS* l:prod
			( PLUS+ r:prod			{ l.ival += r.ival }
			| MINUS r:prod			{ l.ival -= r.ival }
			)*						{ $$.ival = l.ival }

prod	=	l:neg
			( MULTI		r:neg		{ l.ival *= r.ival }
			| DIVIDE	r:neg		{ l.ival /= r.ival }
			| MODULO	r:neg		{ l.ival %= r.ival }
			)*						{ $$.ival = l.ival }

neg		=	MINUS n:neg				{ $$.ival = -n.ival }
			| n:value				{ $$.ival = n.ival }

value	=	n:NUMBER				{ $$.ival = n.ival }
			| l:IDENT				{ symbol_t *fsymb = intern(l.sval, false); $$.ival = (fsymb != NULL) ? (fsymb->defined == true) ? fsymb->value : 0 : 0 }

-		=	[ \t]*
NUMBER	=	< [0-9]+ >	-			{ $$.ival = atoi(yytext) }
PLUS	=	'+'			-
MINUS	=	'-'			-
MULTI	=	'*'			-
DIVIDE	=	'/'			-
MODULO	=	'%'			-
EQUAL	=	'='			-
IDENT	=	< [a-zA-Z]+ >	-		{ $$.sval = yytext }

%%

int main(int argc, char **argv)
{
	while (yyparse()) {
		printf("%d\n", yylval.ival);
	}

	return 0;
}
