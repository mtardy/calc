%{

/* compile:	leg -o calc.c calc.leg
 *		cc -o calc calc.c
 *
 * run:		( echo a=2*3; echo b=3+4; echo c=a*b ) | ./calc
 */

#define SYMBOL_PAYLOAD			\
	oop     value;				\
	int     defined

#define SYMBOL_INITIALISE(S)	\
	S.value = null;				\
	S.defined = false

#include "object.c"

// this should stay out of object.c because it manipulates Symbol members defined in this file

oop update_symbol_value(oop symbol, oop integer)
{
	//_checkType(symbol, Symbol);
	// For now it will fail with assigning to null
	// because for now we can write "a=2 b=a" because everything is passed by value
	//_checkType(integer, Integer);
	set(symbol, Symbol, value, integer); // checktyype is implicit, and it's ok for symbols to store any object value?
	return symbol;
}

#define YYSTYPE oop

YYSTYPE yylval;

%}

start	=	e:exp					{ yylval = e }

exp		=	- (a:assign				{ $$ = a }
			| d:delete				{ $$ = d }
			| p:prim 				{ $$ = p }
			)

assign	=	l:IDENT EQUAL p:prim	{ $$ = update_symbol_value(l, p) }

# it is really unhappy that I have to repeate the code in value because
# I need both information: map identifier and the key
delete	=	DEL 
			(	i:IDENT DOT p:STRING
			|	i:IDENT LBRAC p:prim RBRAC
			)						{ $$ = map_del(get(i, Symbol, value), p) }

prim	=	( s:sum					{ $$ = s } 
			| s:string 				{ $$ = s }
			| m:map					{ $$ = m }
			)

# Map
map		=	LCB RCB					{ $$ = makeMap() }
		|	LCB p:prop RCB			{ $$ = p; }

prop	=	k:STRING COLON v:prim COMMA p:prop				{ $$ = map_set(p, k, v) }
		|	k:STRING COLON v:prim							{ $$ = map_set(makeMap(), k, v) }

# String
string	=	(SQUOTE | DQUOTE) s:STRING (SQUOTE | DQUOTE)	{ $$ = s }

# Number
sum		=	l:prod
			( PLUS+ r:prod			{ get(l, Integer, value) += get(r, Integer, value) }
			| MINUS r:prod			{ get(l, Integer, value) -= get(r, Integer, value) }
			)*						{ $$ = l }

prod	=	l:sign
			( MULTI		r:sign		{ get(l, Integer, value) *= get(r, Integer, value) }
			| DIVIDE	r:sign		{ get(l, Integer, value) /= get(r, Integer, value) }
			| MODULO	r:sign		{ get(l, Integer, value) %= get(r, Integer, value) }
			)*						{ $$ = l }

sign	=	MINUS n:sign			{ set(n, Integer, value, -get(n, Integer, value));  $$ = n }
		|	PLUS  n:sign			{ $$ = n }
		|	n:value					{ $$ = n }

value	=	n:NUMBER				{ $$ = n }
		|	NULL					{ $$ = null }
		|	i:IDENT DOT s:STRING	{ $$ = map_get(get(i, Symbol, value), s) }
		|	i:IDENT LBRAC p:prim RBRAC	{ $$ = map_get(get(i, Symbol, value), p) }
		|	i:IDENT					{ $$ = get(i, Symbol, value) }

-		=	[ \t\n\r]*
IDENT	=	< [a-zA-Z][a-zA-Z0-9_]* >	-	{ $$ = intern(yytext) }
STRING	=	< [a-zA-Z][a-zA-Z0-9_]* >	-	{ $$ = makeString(yytext) }
NUMBER	=	< [0-9]+ >	-					{ $$ = makeInteger(atoi(yytext)) }
PLUS	=	'+'			-
MINUS	=	'-'			-
MULTI	=	'*'			-
DIVIDE	=	'/'			-
MODULO	=	'%'			-
EQUAL	=	'='			-
NULL	=	'null'		-
DEL		=	'del'		-
COLON	=	':'			-
COMMA	=	','			-
DOT		=	'.'			-
LCB		=	'{'			-
RCB		=	'}'			-
LBRAC	=	'['			-
RBRAC	=	']'			-
DQUOTE	=	'"'			-
SQUOTE	=	"'"			-

%%

int main(int argc, char **argv)
{
	while (yyparse()) {
		println(yylval);
	}

	return 0;
}
