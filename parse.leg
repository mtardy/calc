%{

/* compile:	leg -o parse.c parse.leg
 *		cc -o parse parse.c
 *
 * run:		echo "3+4"  | ./parse
 */

#define DO_PROTOS() _DO(map) _DO(call) _DO(func) _DO(declaration) _DO(assign) _DO(symbol) _DO(integer) _DO(string) _DO(add) _DO(sub) _DO(mul) _DO(div) _DO(mod) _DO(getMember) _DO(setMember) _DO(getIndex) _DO(setIndex)

typedef enum {
t_UNDEFINED=0,
#define _DO(NAME) t_##NAME,
DO_PROTOS()
#undef _DO
} proto_t;

#define SYMBOL_PAYLOAD proto_t prototype;

#include "object.c"

// this is the global scope
oop globals;

#define DO_SYMBOLS() DO_PROTOS() _DO(__proto__) _DO(__name__) _DO(name) _DO(body) _DO(param) _DO(key) _DO(value) _DO(lhs) _DO(rhs) _DO(scope) _DO(args)

#define _DO(NAME) oop NAME##_symbol;
DO_SYMBOLS()
#undef _DO

#define _DO(NAME) oop NAME##_proto;
DO_PROTOS()
#undef _DO

oop newObject(oop proto)
{
    oop map = makeMap();
    map_set(map, __proto___symbol, proto);
    return map;
}

void printObjectName(oop object)
{
    assert(is(Map, object));
    oop name = map_get(object, __name___symbol);
    if (name != null) {
        println(name);
        return;
    }

    oop proto = map_get(object, __proto___symbol);
    if (proto != null) {
        printObjectName(proto);
    } else {
        fprintf(stderr, "\nThis map has no name\n");
    }
}

oop newMap()
{
    oop map = newObject(map_proto);
    return map;
}

oop newDeclaration(oop name, oop exp)
{
    oop declaration = newObject(declaration_proto);
    map_set(declaration, lhs_symbol, name);
    map_set(declaration, rhs_symbol, exp);
    return declaration;
}

oop newAssign(oop lhs, oop rhs)
{
    oop assign = newObject(assign_proto);
    map_set(assign, lhs_symbol, lhs);
    map_set(assign, rhs_symbol, rhs);
    return assign;
}

// take char *name or oop already interned?
oop newSymbol(oop name)
{
    oop symbol = newObject(symbol_proto);
    // what is the less confusing, name or value? maybe another word like identifier?
    map_set(symbol, value_symbol, name);
    return symbol;
}

oop newInteger(int value)
{
    oop integer = newObject(integer_proto);
    map_set(integer, value_symbol, makeInteger(value));
    return integer;
}

oop newString(char *value)
{
    oop string = newObject(string_proto);
    oop primitive_string = makeString(value);
    map_set(string, value_symbol, primitive_string);
    return string;
}

oop newBinary(oop proto, oop lhs, oop rhs)
{
    oop obj = newObject(proto);
    map_set(obj, lhs_symbol, lhs);
    map_set(obj, rhs_symbol, rhs);
    return obj;
}

// factorize a bit or not?
oop newSetMember(oop map, oop key, oop value)
{
    oop obj = newObject(setMember_proto);
    map_set(obj, map_symbol, map);
    map_set(obj, key_symbol, key);
    map_set(obj, value_symbol, value);
    return obj;
}

oop newGetMember(oop map, oop key)
{
    oop obj = newObject(getMember_proto);
    map_set(obj, map_symbol, map);
    map_set(obj, key_symbol, key);
    return obj;
}

oop newSetIndex(oop map, oop key, oop value)
{
    oop obj = newObject(setIndex_proto);
    map_set(obj, map_symbol, map);
    map_set(obj, key_symbol, key);
    map_set(obj, value_symbol, value);
    return obj;
}

oop newGetIndex(oop map, oop key)
{
    oop obj = newObject(getIndex_proto);
    map_set(obj, map_symbol, map);
    map_set(obj, key_symbol, key);
    return obj;
}

oop newFunc(oop name, oop param, oop body)
{
    oop func = newObject(func_proto);
    map_set(func, name_symbol, name);
    map_set(func, param_symbol, param);
    map_set(func, body_symbol, body);
    return func;
}

oop newCall(oop func, oop args)
{
    oop call = newObject(call_proto);
    map_set(call, func_symbol, func);
    map_set(call, args_symbol, args);
    return call;
}

// this always creates the key in "object"
oop newVariable(oop object, oop key, oop value)
{
    map_set(object, key, value);
    return value;
}

// this looks in object and everything in the __proto__ chain until it finds the key
oop getVariable(oop object, oop key)
{
    while (!map_hasKey(object, key)) {
        object = map_get(object, __proto___symbol);
        if (object == null) {
            return null;
        }
    }
    return map_get(object, key);
}

// this follows the __proto__ chain until it finds the key, if it fails it behaves like newMember
oop setVariable(oop object, oop key, oop value)
{
    while (!map_hasKey(object, key)) {
        object = map_get(object, __proto___symbol);
        if (object == null) {
            fprintf(stderr, "\nUndefined, %s\n", get(key, Symbol, name));
            exit(1);
        }
    }
    return map_set(object, key, value);
}

#define YYSTYPE oop

YYSTYPE yylval;

%}

start   = - e:exp               { yylval = e }

exp     =   VAR l:IDENT                         EQUAL e:exp { $$ = newDeclaration(l, e) }
        |   VAR l:IDENT                                     { $$ = newDeclaration(l, null) }
        |   FUN l:IDENT                   p:paramList e:exp { $$ = newFunc(l, p, e) }
        |       l:IDENT                         EQUAL e:exp { $$ = newAssign(l, e) }
        |       l:postfix DOT   i:IDENT         EQUAL e:exp { $$ = newSetMember(l, i, e) }
        |       l:postfix LBRAC i:exp   RBRAC   EQUAL e:exp { $$ = newSetIndex(l, i, e) }
        |       s:sum                                       { $$ = s }

sum     =   l:prod
            ( PLUS+ r:prod          { l = newBinary(add_proto, l, r) }
            | MINUS r:prod          { l = newBinary(sub_proto, l, r) }
            )*                      { $$ = l }

prod    =   l:prefix
            ( MULTI     r:prefix        { l = newBinary(mul_proto, l, r) }
            | DIVIDE    r:prefix        { l = newBinary(div_proto, l, r) }
            | MODULO    r:prefix        { l = newBinary(mod_proto, l, r) }
            )*                          { $$ = l }

prefix  =   MINUS n:prefix              { set(n, Integer, value, -get(n, Integer, value));  $$ = n }
        |   PLUS  n:prefix              { $$ = n }
        |         n:postfix             { $$ = n }

postfix =   i:value ( DOT    s:IDENT        a:argumentList      { map_set(a, intern("this"), i); i = newCall(i, a) }
                    | DOT    s:IDENT        !EQUAL              { i = newGetMember(i, s) }
                    | LBRAC  p:exp   RBRAC  !EQUAL              { i = newGetIndex(i, p) }
                    | a:argumentList                            { i = newCall(i, a) }
                    ) *                                         { $$ = i }

paramList    = LPAREN  m:makeMap
                ( i:IDENT           { map_append(m, i) }
                ( COMMA i:IDENT     { map_append(m, i) }
                ) *
                ) ?
                RPAREN              { $$ = m }

argumentList = LPAREN  m:makeMap
                ( e:exp             { map_append(m, e) }
                ( COMMA e:exp       { map_append(m, e) }
                ) *
                ) ?
                RPAREN              { $$ = m }

value   =   n:NUMBER                { $$ = n }
        |   s:string                { $$ = s }
        |   s:symbol                { $$ = s }
        |   m:map                   { $$ = m }
        |   NULL                    { $$ = null }
        |   i:IDENT                 { $$ = i }
        |   LPAREN i:exp RPAREN     { $$ = i }

string  =   SQUOTE < (!SQUOTE .)* > SQUOTE      { $$ = newString(yytext) }
        |   DQUOTE < (!DQUOTE .)* > DQUOTE      { $$ = newString(yytext) }

symbol  =   HASH    ( i:IDENT                   { $$ = newSymbol(i) }
                    | i:string                  { $$ = newSymbol(intern(get(i, String, value))) }
                    )

map     =   LCB   m:newMap
            (           k:IDENT COLON v:exp     { map_set(m, k, v) }
            (     COMMA k:IDENT COLON v:exp     { map_set(m, k, v) }
            ) *
            ) ?
            RCB                                 { $$ = m }

makeMap=   { $$ = makeMap() }
newMap =   { $$ = newMap() }

-       =   [ \t\n\r]*
        | "//"  ( ![\n\r] . )*

IDENT	=	< [a-zA-Z][a-zA-Z0-9_]* >   -   { $$ = intern(yytext) }
NUMBER	=	< [0-9]+ >	-                   { $$ = newInteger(atoi(yytext)) }
FUN     =   'fun'  ![a-zA-Z0-9_]        -
VAR     =   'var'  ![a-zA-Z0-9_]        -
NULL	=	'null' ![a-zA-Z0-9_]	    -
HASH	=	'#'			-
PLUS	=	'+'			-
MINUS	=	'-'			-
MULTI	=	'*'			-
DIVIDE	=	'/'			-
MODULO	=	'%'			-
EQUAL	=	'='			-
COLON	=	':'			-
COMMA	=	','			-
DOT		=	'.'			-
LCB		=	'{'			-
RCB		=	'}'			-
LBRAC	=	'['			-
RBRAC	=	']'			-
LPAREN	=	'('			-
RPAREN	=	')'			-
DQUOTE	=	'"'			-
SQUOTE	=	"'"			-

%%
;

int getInteger(oop obj)
{
    return get(obj, Integer, value);
}

oop map_fromArrays(oop keys, oop values)
{
    assert(is(Map, keys));
    assert(is(Map, values));
    int i = 0;
    oop map = makeMap();
    oop key, value;
    oop index;
    while ((index = makeInteger(i)), map_hasKey(keys, index)) {
        key = map_get(keys, index);
        value = map_get(values, index);
        map_set(map, key, value);
        i++;
    }
    return map;
}

oop evalArgs(oop scope, oop args);

oop eval(oop scope, oop ast)
{
    switch(ast->type) {
    case Undefined:
    case Integer:
    case String:
    case Function:
        return ast;
    case Symbol:
        return map_get(scope, ast);
    }

    oop proto = map_get(ast, __proto___symbol);
    if (proto == null) {
        return ast;
    }
    // proto_number is the enum version of the proto symbol
    proto_t proto_number = get(map_get(proto, __name___symbol), Symbol, prototype);
    switch (proto_number) {
    case t_map: {
        return ast;
    }
    case t_declaration: {
        oop lhs = map_get(ast, lhs_symbol);
        oop rhs = eval(scope, map_get(ast, rhs_symbol));
        return newVariable(scope, lhs, rhs);
    }
    case t_assign: {
        oop lhs = map_get(ast, lhs_symbol);
        oop rhs = eval(scope, map_get(ast, rhs_symbol));
        return setVariable(scope, lhs, rhs);
    }
    case t_func: {
        oop name = map_get(ast, name_symbol);
        oop param = map_get(ast, param_symbol);
        oop body = map_get(ast, body_symbol);
        return newVariable(scope, name, makeFunction(NULL, param, body));
    }
    case t_call: {
        oop func = eval(scope, map_get(ast, func_symbol));
        oop args = evalArgs(scope, map_get(ast, args_symbol));
        if (get(func, Function, primitive) == NULL) {
            oop param = get(func, Function, param);
            oop localScope = map_fromArrays(param, args);
            return eval(localScope, get(func, Function, body));
        }
        return get(func, Function, primitive)(args);
    }
    case t_getMember: {
        oop map = eval(scope, map_get(ast, map_symbol));
        oop key = map_get(ast, key_symbol);
        return map_get(map, key);
    }
    case t_setMember: {
        oop map = eval(scope, map_get(ast, map_symbol));
        oop key = map_get(ast, key_symbol);
        oop value = eval(scope, map_get(ast, value_symbol));
        return map_set(map, key, value);
    }
    case t_getIndex: {
        oop map = eval(scope, map_get(ast, map_symbol));
        oop key = eval(scope, map_get(ast, key_symbol));
        return map_get(map, key);
    }
    case t_setIndex: {
        oop map = eval(scope, map_get(ast, map_symbol));
        oop key = eval(scope, map_get(ast, key_symbol));
        oop value = eval(scope, map_get(ast, value_symbol));
        return map_set(map, key, value);
    }
    case t_symbol:
    case t_integer:
    case t_string: {
        return map_get(ast, value_symbol);
    }
    case t_add: {
        oop lhs = eval(scope, map_get(ast, lhs_symbol));
        oop rhs = eval(scope ,map_get(ast, rhs_symbol));
        return makeInteger(getInteger(lhs) + getInteger(rhs));
    }
    case t_sub: {
        oop lhs = eval(scope, map_get(ast, lhs_symbol));
        oop rhs = eval(scope ,map_get(ast, rhs_symbol));
        return makeInteger(getInteger(lhs) - getInteger(rhs));
    }
    case t_mul: {
        oop lhs = eval(scope, map_get(ast, lhs_symbol));
        oop rhs = eval(scope ,map_get(ast, rhs_symbol));
        return makeInteger(getInteger(lhs) * getInteger(rhs));
    }
    case t_div: {
        oop lhs = eval(scope, map_get(ast, lhs_symbol));
        oop rhs = eval(scope ,map_get(ast, rhs_symbol));
        return makeInteger(getInteger(lhs) / getInteger(rhs));
    }
    case t_mod: {
        oop lhs = eval(scope, map_get(ast, lhs_symbol));
        oop rhs = eval(scope ,map_get(ast, rhs_symbol));
        return makeInteger(getInteger(lhs) % getInteger(rhs));
    }
    default: {
        assert(0);
        break;
    }
    }
    return null;
}

oop prim_exit(oop params)
{
    printf("bye bye with params ");
    println(params);
    exit(0);
}

oop evalArgs(oop scope, oop args)
{
   int i = 0;
   oop params = makeMap();
   oop index;
   while ((index = makeInteger(i)), map_hasKey(args, index)) {
       map_set(params, index, eval(scope, map_get(args, index)));
       i++;
   }
   return params;
}

int main(int argc, char **argv)
{
    symbol_table = makeMap();
    globals = makeMap();

    map_set(globals, intern("exit"), makeFunction(prim_exit, null, null));

    #define _DO(NAME) NAME##_symbol=intern(#NAME);
    DO_SYMBOLS()
    #undef _DO

    #define _DO(NAME) set(NAME##_symbol, Symbol, prototype, t_##NAME);
    DO_PROTOS()
    #undef _DO

    // instanciate protos with empty Map and fill their name
    #define _DO(NAME) NAME##_proto=makeMap(); map_set(NAME##_proto, __name___symbol, NAME##_symbol);
    DO_PROTOS()
    #undef _DO


    /*
    oop myInteger = newInteger(32);
    println(myInteger);
    oop myAddition = newBinary(add_proto, myInteger, myInteger);
    println(myAddition);

    printObjectName(myAddition);
    printObjectName(myInteger);
    */

    /*
    oop myFirst = newObject(null);
    oop myPizzaSymbol = makeSymbol("pizza");
    map_set(myFirst, myPizzaSymbol, makeInteger(3));
    oop mySecond = newObject(myFirst);
    oop myThird = newObject(mySecond);
    map_set(mySecond, myPizzaSymbol, makeInteger(4));
    println(myThird);
    println(getVariable(mySecond, myPizzaSymbol));
    */


    while (yyparse()) {
        println(yylval);
        println(eval(globals, yylval));
    }

    return 0;

    (void)yyAccept;
}